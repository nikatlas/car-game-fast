<!DOCTYPE html>
<html lang="en">
	<head>
		<title>CarGame Test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				z-index: 100;
				display:block;
			}
			#info a, .button { color: #f00; font-weight: bold; text-decoration: underline; cursor: pointer }
		</style>
	</head>

	<body>
		<div id="info">
		<a href="http://threejs.org" target="_blank">three.js</a> - OBJMTLLoader test
		</div>

		<script src="js/three.min.js"></script>

		<script src="js/loaders/DDSLoader.js"></script>
		<script src="js/loaders/MTLLoader.js"></script>
		<script src="js/loaders/OBJMTLLoader.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script>
			var MAX_VELOCITY = 200000, MAX_ANGULAR_VELOCITY = 1000, LINEAR_TO_ANGULAR = 30;
			var container, stats;

			var camera, scene, renderer;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
		
			var cube,car;
			var clock = new THREE.Clock(true);
			var keys = [];
			
			init();
			animate();


			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.y = 10;
				camera.position.z = 10;

				// scene

				scene = new THREE.Scene();

				var ambient = new THREE.AmbientLight( 0xbbbbbb );
				scene.add( ambient );

				var directionalLight = new THREE.DirectionalLight( 0xffeedd );
				directionalLight.position.set( 0, 0, 1 ).normalize();
				scene.add( directionalLight );
				
				directionalLight = new THREE.DirectionalLight( 0xffeedd );
				directionalLight.position.set( 1, 1, 0 ).normalize();
				scene.add( directionalLight );

				// FLOOR 
				// material
				var texture = THREE.ImageUtils.loadTexture( 'textures/grass_1.jpg' );
				texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
				texture.repeat.set( 20, 20 );

			    // cube
				material = new THREE.MeshPhongMaterial( {
				   color: 0xffffff,
				   specular:0xffffff,
				   shininess: 2222,
				   map: texture,
				   combine: THREE.MixOperation,
				   reflectivity: 0.05
				} );
				cube = new THREE.Mesh(new THREE.CubeGeometry(50, 1, 50), material);
		    	cube.overdraw = true;
				cube.position.y = 0;
		    	scene.add(cube);
				
				
				// model
				THREE.Loader.Handlers.add( /\.dds$/i, new THREE.DDSLoader() );
				//*
				var loader = new THREE.OBJMTLLoader();
				loader.load( 'obj/lamborgini/Avent.obj', 'obj/lamborgini/Avent.mtl', function ( object ) {
					object.position.y = 0.45;
					object.scale.x = 
					object.scale.y =
					object.scale.z = 1;
					scene.add( object );
					car = object;				
					car.velocity = 0;
					car.angularVelocity = 0;
					car.acc = 0;
					car.brake = MAX_VELOCITY;
					car.angularBrake = MAX_ANGULAR_VELOCITY;
					car.applyResistance = function (){
						this.velocity += -this.velocity/100;
						if( !keys[65] && !keys[68] ) {
							car.angularVelocity /= 1.3;	
						}
					}
				} );
				/*/
				var loader = new THREE.ObjectLoader();
				loader.load('obj/lamborgini/Avent.js', function( object ) {
					//object = new THREE.Mesh( geometry, materials );
					object.position.y = 0.45;
					object.scale.x = 
					object.scale.y =
					object.scale.z = 1;
					scene.add( object );
					car = object;				
					car.velocity = 0;
					car.acc = 0;
					car.brake = MAX_VELOCITY;
					car.applyResistance = function (){
						this.velocity += -this.velocity/100;
					}
				} );
				//*/

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				//document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'keydown', onKeyboardDown, false );
				document.addEventListener( 'keyup', onKeyboardUp, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX ) / 2;
				mouseY = ( event.clientY - windowHalfY ) / 2;

			}

			function onKeyboardDown( event ) {
				keys[event.keyCode] = 1;
			}
			function onKeyboardUp( event ) {
				keys[event.keyCode] = 0;
			}


			
			//
			function moveCar(dt){				
				if ( car ){//CAR KEYS
						if( keys[83] ){						
							if( car.velocity > 0 ) {
								var t = Math.sqrt(MAX_VELOCITY - car.velocity);
								if( t > 0 ){ 
									car.velocity += t;
									car.brake -= t;
								}
								else{
									car.velocity = MAX_VELOCITY;
									car.brake = 0;
								}
							}else{
								var t = Math.sqrt(MAX_VELOCITY - car.brake);
								if( t > 0 ){
									car.velocity += t;
									car.brake += t;
								}
								else{
									car.velocity = MAX_VELOCITY;
									car.brake = MAX_VELOCITY;
								}
							}
						}
						if ( keys[ 87 ] ){ //s
							if( car.velocity > 0 ){
								var t = Math.sqrt(MAX_VELOCITY - car.brake);
								if( t > 0 ){
									car.velocity -= t;
									car.brake += t;
								}else{
									car.velocity = 0;
									car.brake = MAX_VELOCITY;
								}
							}
							else{
								var t = Math.sqrt(MAX_VELOCITY + car.velocity);
								if( t > 0 ){
									car.velocity -= t;
									car.brake -= t;
								}else{
									car.velocity = -MAX_VELOCITY;
									car.brake = 0;
								}
							}
						}
						if ( keys[ 65 ] ){ //a
							if( car.angularVelocity > 0 ) {
								var t = Math.sqrt(MAX_ANGULAR_VELOCITY - car.angularVelocity);
								if( t > 0 ){ 
									car.angularVelocity += t;
									car.angularBrake -= t;
								}
								else{
									car.angularVelocity = MAX_ANGULAR_VELOCITY;
									car.angularBrake = 0;
								}
							}else{
								var t = Math.sqrt(MAX_ANGULAR_VELOCITY - car.angularBrake);
								if( t > 0 ){
									car.angularVelocity += t;
									car.angularBrake += t;
								}
								else{
									car.angularVelocity = MAX_ANGULAR_VELOCITY;
									car.angularBrake = MAX_ANGULAR_VELOCITY;
								}
							}						
						}
						if ( keys[ 68 ] ){ //d
							if( car.angularVelocity > 0 ){
								var t = Math.sqrt(MAX_ANGULAR_VELOCITY - car.angularBrake);
								if( t > 0 ){
									car.angularVelocity -= t;
									car.angularBrake += t;
								}else{
									car.angularVelocity = 0;
									car.angularBrake = MAX_ANGULAR_VELOCITY;
								}
							}
							else{
								var t = Math.sqrt(MAX_ANGULAR_VELOCITY + car.angularVelocity);
								if( t > 0 ){
									car.angularVelocity -= t;
									car.angularBrake -= t;
								}else{
									car.angularVelocity = -MAX_ANGULAR_VELOCITY;
									car.angularBrake = 0;
								}
							}
						}
						
						
						car.rotation.y += - LINEAR_TO_ANGULAR * car.velocity / MAX_VELOCITY * car.angularVelocity * dt * 0.001;
						
						var vector = new THREE.Vector3( 1, 0, 0 )
						var axis = new THREE.Vector3( 0, 1, 0 );
						var angle = car.rotation.y;
						var matrix = new THREE.Matrix4().makeRotationAxis( axis, angle );
						vector.applyMatrix4( matrix );

						car.position.x += car.velocity*dt * 0.001 * vector.x;
						car.position.z += car.velocity*dt * 0.001 * vector.z;

						car.applyResistance(dt);
						camera.position.x = car.position.x + 10*vector.x;
						camera.position.y = car.position.y + 10*vector.y + 5;
						camera.position.z = car.position.z + 10*vector.z;
						
						camera.lookAt( car.position  );
						
					}	
			}
			function animate() {

				requestAnimationFrame( animate );
				render();
				
			}
			
			function render() {

				//camera.position.x += ( mouseX - camera.position.x ) * .05;
				//camera.position.y += ( - mouseY - camera.position.y ) * .05;
				if( car ){
					
				}

				var dt = clock.getDelta();
				moveCar(dt);
				
				renderer.render( scene, camera );
			}

		</script>

	</body>
</html>
